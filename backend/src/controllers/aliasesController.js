/**
 * ALIASES CONTROLLER
 * 
 * API endpoints for managing the aliases system
 * Provides CRUD operations, search functionality, and analytics
 */

const aliasesService = require('../services/aliasesService');

// ========================================
// CRUD OPERATIONS
// ========================================

// Create a new alias
const createAlias = async (req, res, next) => {
  try {
    const {
      entityType,
      entityId,
      aliasText,
      aliasType = 'alternative',
      confidenceScore = 1.0,
      isPrimary = false,
      isAutoGenerated = false,
      source = 'manual',
      context = null,
      notes = null
    } = req.body;

    // Validate required fields
    if (!entityType || !entityId || !aliasText) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: entityType, entityId, aliasText'
      });
    }

    // Validate entity type
    const validEntityTypes = ['college', 'program', 'city', 'state', 'university'];
    if (!validEntityTypes.includes(entityType)) {
      return res.status(400).json({
        success: false,
        error: `Invalid entity type. Must be one of: ${validEntityTypes.join(', ')}`
      });
    }

    // Validate alias type
    const validAliasTypes = ['abbreviation', 'acronym', 'nickname', 'misspelling', 'alternative', 'short_form', 'common_name'];
    if (!validAliasTypes.includes(aliasType)) {
      return res.status(400).json({
        success: false,
        error: `Invalid alias type. Must be one of: ${validAliasTypes.join(', ')}`
      });
    }

    // Validate confidence score
    if (confidenceScore < 0 || confidenceScore > 1) {
      return res.status(400).json({
        success: false,
        error: 'Confidence score must be between 0 and 1'
      });
    }

    const result = await aliasesService.createAlias({
      entityType,
      entityId,
      aliasText,
      aliasType,
      confidenceScore,
      isPrimary,
      isAutoGenerated,
      source,
      context,
      notes,
      createdBy: req.user?.id || null
    });

    if (result.success) {
      res.status(201).json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Get aliases for an entity or all aliases
const getAliases = async (req, res, next) => {
  try {
    const { entityType, entityId } = req.query;

    const result = await aliasesService.getAliases(entityType, entityId);

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Update an alias
const updateAlias = async (req, res, next) => {
  try {
    const { aliasId } = req.params;
    const updateData = req.body;

    // Validate alias ID
    if (!aliasId || isNaN(aliasId)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid alias ID'
      });
    }

    const result = await aliasesService.updateAlias(parseInt(aliasId), updateData);

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Delete an alias
const deleteAlias = async (req, res, next) => {
  try {
    const { aliasId } = req.params;

    // Validate alias ID
    if (!aliasId || isNaN(aliasId)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid alias ID'
      });
    }

    const result = await aliasesService.deleteAlias(parseInt(aliasId));

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// ========================================
// SEARCH OPERATIONS
// ========================================

// Search entities by alias
const searchByAlias = async (req, res, next) => {
  try {
    const { q: query, entityType, limit = 50 } = req.query;

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Search query is required'
      });
    }

    const result = await aliasesService.searchByAlias(
      query.trim(),
      entityType,
      parseInt(limit)
    );

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Get entity by alias
const getEntityByAlias = async (req, res, next) => {
  try {
    const { q: query, entityType } = req.query;

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Search query is required'
      });
    }

    const result = await aliasesService.getEntityByAlias(query.trim(), entityType);

    if (result.success) {
      res.json(result);
    } else {
      res.status(404).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// ========================================
// AUTOMATIC GENERATION
// ========================================

// Generate aliases for an entity
const generateAliases = async (req, res, next) => {
  try {
    const { entityType, entityId, entityName } = req.body;

    // Validate required fields
    if (!entityType || !entityId || !entityName) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: entityType, entityId, entityName'
      });
    }

    // Validate entity type
    const validEntityTypes = ['college', 'program', 'city', 'state', 'university'];
    if (!validEntityTypes.includes(entityType)) {
      return res.status(400).json({
        success: false,
        error: `Invalid entity type. Must be one of: ${validEntityTypes.join(', ')}`
      });
    }

    const result = await aliasesService.generateAliasesForEntity(
      entityType,
      entityId,
      entityName
    );

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Generate aliases for all colleges
const generateAllCollegeAliases = async (req, res, next) => {
  try {
    const dbManager = require('../database/DatabaseManager');
    await dbManager.initialize();
    const db = dbManager.getDatabase('clean-unified.db');

    // Get all colleges
    const colleges = await db.all('SELECT id, name FROM colleges WHERE status = "active"');

    let totalGenerated = 0;
    const results = [];

    for (const college of colleges) {
      const result = await aliasesService.generateAliasesForEntity(
        'college',
        college.id,
        college.name
      );

      if (result.success) {
        totalGenerated += result.count;
        results.push({
          collegeId: college.id,
          collegeName: college.name,
          generatedCount: result.count
        });
      }
    }

    res.json({
      success: true,
      message: `Generated aliases for ${colleges.length} colleges`,
      totalGenerated,
      results
    });
  } catch (error) {
    next(error);
  }
};

// ========================================
// STATISTICS AND ANALYTICS
// ========================================

// Get alias statistics
const getAliasStatistics = async (req, res, next) => {
  try {
    const result = await aliasesService.getAliasStatistics();

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// Get top used aliases
const getTopUsedAliases = async (req, res, next) => {
  try {
    const { limit = 20 } = req.query;

    const result = await aliasesService.getTopUsedAliases(parseInt(limit));

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    next(error);
  }
};

// ========================================
// BULK OPERATIONS
// ========================================

// Bulk create aliases
const bulkCreateAliases = async (req, res, next) => {
  try {
    const { aliases } = req.body;

    if (!Array.isArray(aliases) || aliases.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Aliases array is required and must not be empty'
      });
    }

    const results = [];
    let successCount = 0;
    let errorCount = 0;

    for (const aliasData of aliases) {
      const result = await aliasesService.createAlias({
        ...aliasData,
        createdBy: req.user?.id || null
      });

      results.push(result);

      if (result.success) {
        successCount++;
      } else {
        errorCount++;
      }
    }

    res.json({
      success: true,
      message: `Processed ${aliases.length} aliases`,
      successCount,
      errorCount,
      results
    });
  } catch (error) {
    next(error);
  }
};

// Bulk update aliases
const bulkUpdateAliases = async (req, res, next) => {
  try {
    const { updates } = req.body;

    if (!Array.isArray(updates) || updates.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Updates array is required and must not be empty'
      });
    }

    const results = [];
    let successCount = 0;
    let errorCount = 0;

    for (const update of updates) {
      const { aliasId, ...updateData } = update;

      if (!aliasId) {
        results.push({
          success: false,
          error: 'aliasId is required for each update'
        });
        errorCount++;
        continue;
      }

      const result = await aliasesService.updateAlias(aliasId, updateData);
      results.push(result);

      if (result.success) {
        successCount++;
      } else {
        errorCount++;
      }
    }

    res.json({
      success: true,
      message: `Processed ${updates.length} updates`,
      successCount,
      errorCount,
      results
    });
  } catch (error) {
    next(error);
  }
};

// ========================================
// EXPORT/IMPORT
// ========================================

// Export aliases to CSV
const exportAliases = async (req, res, next) => {
  try {
    const { entityType, entityId, format = 'csv' } = req.query;

    const result = await aliasesService.getAliases(entityType, entityId);

    if (!result.success) {
      return res.status(400).json(result);
    }

    if (format === 'csv') {
      // Convert to CSV format
      const csvHeader = 'ID,Entity Type,Entity ID,Entity Name,Alias Text,Normalized Alias,Alias Type,Confidence Score,Usage Frequency,Is Primary,Is Auto Generated,Source,Context,Notes,Status,Created At,Updated At\n';
      
      const csvRows = result.aliases.map(alias => 
        `${alias.id},"${alias.entityType}",${alias.entityId},"${alias.entityName || ''}","${alias.aliasText}","${alias.normalizedAlias}","${alias.aliasType}",${alias.confidenceScore},${alias.usageFrequency},${alias.isPrimary},${alias.isAutoGenerated},"${alias.source}","${alias.context || ''}","${alias.notes || ''}","${alias.status}","${alias.createdAt}","${alias.updatedAt}"`
      ).join('\n');

      const csvContent = csvHeader + csvRows;

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename="aliases_export.csv"');
      res.send(csvContent);
    } else {
      res.json(result);
    }
  } catch (error) {
    next(error);
  }
};

module.exports = {
  // CRUD operations
  createAlias,
  getAliases,
  updateAlias,
  deleteAlias,
  
  // Search operations
  searchByAlias,
  getEntityByAlias,
  
  // Automatic generation
  generateAliases,
  generateAllCollegeAliases,
  
  // Statistics and analytics
  getAliasStatistics,
  getTopUsedAliases,
  
  // Bulk operations
  bulkCreateAliases,
  bulkUpdateAliases,
  
  // Export/Import
  exportAliases
};
